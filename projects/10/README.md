# Project 10

## docs

### spec

https://drive.google.com/file/d/1O1nTS24VM2kp_ilTZCrBZOryhTK1e0qN/view

## todo

- [x] JackTokenizer
- [ ] CompilationEngine

## memo

- 토큰화 모듈
  - 메모리 효율성과 최적화를 생각하기보다는 최대한 간단하게 구현하려고 하였다. 파일의 개수가 적고 라인 수도 적은 경우 효율성이 그렇게 중요한 척도는 아니기 때문이다.
  - ~~현재는 전체 파일 내용을 모두 다 읽어들여 string 변수로 저장한 후 계속해서 토근화하면서 남아 있는 string이 없을 때까지 반복하는 식으로 구현하였다.~~ => 파일을 읽어들일 때 전체 토큰화 작업을 완료한다. 만약 토큰의 개수가 너무 많으면 차례대로 읽으면서 파싱하는 것이 메모리 효율적일 수도 있겠지만 그렇게 토큰이 많을 일은 현재 규모에서는 없고, regex를 통해 한번에 주석 제거 및 토큰화를 끝내는 것이 깔끔하다고 판단하였다.
  - regex 해설은 다음과 같다.
    - 우선 **lazy quantifiers** 에 대하여 설명해야 한다. regex에서 기본적으로는 `.*`, `.+` 등을 사용하면 greedy하게 매칭을 찾기 때문에 조건을 만족하는 최대의 덩어리를 찾게 된다. 예를 들어, `1.*2` 와 같은 regex를 `1a2b2` 에 적용할 경우, `a2b` 를 찾는다. 그러나 `a` 만 찾아내고 싶은 상황이 있을 수도 있다. 이 경우는 lazy하게 매칭해주는 `.*?`, `.+?` 를 사용하면 된다.
    - 다음으로 `\b` 에 대해서 설명해야 한다. 이것은 boundary of words 라고 부른다. word라는 것은 `[a-zA-Z0-9_]` 를 의미한다. 이것을 `\w` 로도 사용할 수 있다. 즉, boundary라는 말의 의미는 `\w` 에 매칭되는 문자와 그렇지 않은 문자 **사이**, 그리고 vice versa를 의미한다. 사이라는 말에 강조한 이유는 어떤 문자를 가리키는 것이 아니라 그 위치만 가리키는 가상적인 개념이기 때문이다.
    - `slashSlashCommentRegex`(`//(.*?)\n`): `//` 이 나타난 경우 줄바꿈 문자 '\n' 을 만날 때까지를 찾는다. 이 때 lazy quantifier를 사용하는데, `//` 가 등장한 후 가장 처음 만나는 줄바꿈 문자까지만 찾고 싶기 때문이다.
    - `slashStarCommentRegex`(`/\*((.|\n)*?)\*/`): 아무 문자를 뜻하는 '.' 또는 줄바꿈 문자 '\n' 이 '/\*', '\*/' 사이에 등장하는 경우를 찾는다. 마찬가지로 lazy quantifier를 사용하는데, `/*` 가 등장한 후 가장 처음 만나는 `*/` 까지만 찾고 싶기 때문이다.
    - `keywordRegex`(`\b` + strings.Join(allKeywords, `\b|\b`) + `\b`): `\b` 를 이용하여 각 keyword의 시작과 끝이 non-word 사이에 있는지 판단하고 각 keyword 사이는 `|` 로 or-ing해서 모든 케이스를 검사할 수 있게 한다.
    - `symbolRegex`(`{|}|\(|\)|\[|\]|\.|,|;|\+|\-|\*|/|&|\||<|>|=|~`): escape가 필요한 곳에 모두 `\`를 이용해서 처리한다.
    - `intRegex`(`\b\d+\b`): non-word 사이에 나오는 숫자 리스트여야 한다. 앞에 word가 붙어 있으면 identifier이다.
    - `stringRegex`(`"(.*?)"`): 두 개의 쌍따옴표 사이에 있는 줄바꿈 문자를 제외한 모든 문자를 의미한다. 마찬가지로 `"` 가 등장한 뒤 가장 처음 만나는 `"` 까지만 찾고 싶으므로 lazy quantifier를 사용한다.
    - `identifierRegex`(`\b[a-zA-Z_]\w*\b`): non-word 사이에 있는 (숫자를 제외한 word) + word 리스트를 찾는다.
  - ~~symbol 중에서 '<', '>', '&' 는 XML encoding을 위해 각각 `&lt;`, `&gt;`, `&amp;`로 변환해서 반환한다. 이것은 XML encoding을 하는 쪽에서 변환해서 사용하는 것이 좋다고 생각하지만, 현재 프로젝트에서 XML 외에 다른 포맷으로 변환하지도 않기도 하고 깔끔한 구현을 위해 이렇게 선택하였다.~~ => XML encoding 쪽에서 변환하는 방식으로 변경하였다. 다만 쉬운 변환을 위해 byte 타입 대신 string 타입을 사용한다.
  - XML 출력을 위해 `encoding/xml` 모듈을 사용하지는 않았고 raw string을 이용하여 출력하였다. 이렇게 한 것은 현재 출력하는 tokens XML이 완전한 XML 문법을 지키는 것이 아니기 때문에 오히려 복잡해지기 때문이다. 같은 계층에서 여러 같은 키가 순서가 중요한 채로 출력되어야 하는 것이 공식 문법과 다른 점이다.
