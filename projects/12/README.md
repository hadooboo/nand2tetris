# Project 12

## docs

### spec

https://drive.google.com/file/d/1Qeuor0zqUAR0Q6xGPCuwdfYDAQILjbEm/view

## todo

- [x] Array
- [x] Keyboard
- [x] Math
- [ ] Memory
- [ ] Output
- [ ] Screen
- [x] String
- [x] Sys

## memo

- String
  - 책에서 나온 설명처럼 `setInt`를 재귀적으로 구현하는 것이 깔끔할 수 있으나, 재귀적으로 호출하면서 메모리를 많이 잡아먹으므로 Array 클래스를 스택처럼 이용하여 구현하였다. 이렇게 할 경우 스택 사이즈를 어떻게 결정할 지 미리 예상할 수 없다. 그러나 본 프로젝트는 완벽한 구현이 목적이 아니다.
- Sys
  - `wait` 함수를 구현하기 위해 while 문을 이용하여 무의미한 연산을 잠시 동안 하도록 하였다.
- Math
  - multiply, divide, sqrt 빼고는 다 직관적이다.
  - multiply도 우리가 초등학교 때 했던 대로 전체 수와 각 자리수를 곱해서 더하는 방식을 생각하면 쉽게 접근이 가능하다.
  - divide 알고리즘을 해석하는 방법은 다음과 같다. 예를 들어 19/3으로 생각해보자. 우선 분모를 계속 2배씩 하면서 나눗셈 결과가 가장 먼저 0이 되는 경우를 찾는다. 19/3 -> 19/6 -> 19/12 -> 19/24 끝. 분모가 분자보다 크니까 결과는 무조건 0이다. 그럼 그 전의 항은 결과가 무조건 1일 것이다. 만약 2 이상이었다면 분모를 2배씩 하고 있기 때문에 이번 항에서 최소한 결과가 1 이상이다. 즉, 0.25 X 19/3 의 결과가 1이고, 대충 19/3은 4정도 나올 것이다. 그러나 우리는 답이 6인 것을 알고 있다. 19/12가 정확히 1이 아니기 때문에 발생하는 문제이다. 따라서 이전 항으로 가면서 점점 더 가까이 근사해나가는 과정이 필요하다. 우선 19/12가 1인 것은 확인하였다. 이제 19/6이 얼마인지 확인하려는데, 19/12의 결과인 1에 2를 곱한 후, 분모에 있는 6과 곱한 결과인 12와 분자에 있는 19 사이에 현재 분모인 6이 1번 이상 들어갈 수 있는지 확인하는 과정이 필요하다. 12와 19 사이에는 6이 들어갈 수 있으므로 결과는 1을 더한 3이 된다. 이제 마찬가지로 19/3이 얼마인지 19/6을 통해 확인하자. 19/3은 우선 19/6의 결과인 3에 2를 곱한 6보다 같거나 클 것이다. 분모에 있는 3과 방금 계산한 6을 곱한 결과인 18과 분자에 있는 19 사이에는 3이 들어갈 수 없다. 따라서 결과는 1을 더하지 않고 6이 확정된다. 이 예시를 확장하여 수도코드로 만든 것이 책에 나와 있는 알고리즘이다.
  - sqrt 알고리즘을 해석하는 방법은 다음과 같다. 우선 음수의 루트는 계산을 하지 않을 것이기 때문에 양수만 생각한다. 양수 중에서 가장 큰 32767이 2^8 의 제곱보다 작기 때문에 2^7부터 2^6, ..., 2^0 에 대해서 계산한다. 계산은 "지금 이 숫자를 더해서 제곱했을 때 인풋보다 작거나 같게 유지될 것이냐" 에 대한 것이다. 제곱이 아니라 10진수를 2진수로 변환할 때를 연상하면 간단한데, 13이라는 숫자가 있을 때 "일단 2의 거듭제곱 중 8부터 쓰고, 남은 5를 만들기 위해 4를 쓰고, 남은 1을 만들기 위해 1을 쓰고" 해서 2진수를 만든다. 이를 다시 쓰면, 13보다 작은 2의 거듭제곱 중 큰 것부터 작은 순서대로 더해가는데, 8은 되니까 쓰고, 4는 되니까 쓰고, 2는 더하면 13을 넘어버리니까 쓰지 말고, 1은 되니까 쓰는 것이다. 이것을 sqrt에 적용해보면, 예를 들어 2^7은 되니까 쓰고, 2^6은 더해서 제곱하면 인풋을 넘어버리니까 쓰지 말고, ..., 2^0은 되니까 쓰는 것이다.
  - http://nand2tetris-questions-and-answers-forum.52.s1.nabble.com/MathTest-tst-fails-even-with-provided-OS-vm-files-td4036143.html
    - 나도 1,000,000회의 vmstep으로는 결과가 정상적으로 계산되지 않았다. 더 효율적으로 코드를 작성하면 통과하는 것인지.. 의문스럽긴 하다.
- Keyboard
  - 현재 키보드에 입력 중인 문자는 `Memory.peek(24576)` 을 이용해 알 수 있다.
  - readChar를 구현할 때는 backSpace는 출력하면 안 된다. backSpace는 어떤 문자가 화면에 출력되기를 원하고 누르는 것이 아니라 기존에 입력된 문자를 취소하고 싶은 상황인 것이다. 현재 커서에 있는 것을 무조건 지우려고 하면 기존에 콘솔에 출력된 문자까지 지워버린다.
  - readString을 구현할 때는 readChar를 무한 반복으로 읽다가, newLine을 만나는 경우 리턴하고, backSpace를 만나는 경우 현재 문자열의 길이가 1 이상일 때에 한해 `s.eraseLastChar()`, `Output.printChar(String.backSpace())` 를 연속적으로 호출하여 문자 하나를 메모리와 화면에서 지운다.
  - readInt는 readString과 String의 intValue 메소드를 이용하여 간단하게 구현할 수 있다.
- Array
  - dispose를 할 때, 자기 자신의 주소가 어차피 `Memory.alloc` 함수를 통해 받은 base address이므로 `Memory.deAlloc(this)` 를 통해 자신의 위치 자체의 메모리를 반납하면 된다.
  - Math에서와 마찬가지로 1,000,000회의 vmstep으로는 결과가 정상적으로 계산되지 않았다. 2,000,000회로 변경해두었다.
