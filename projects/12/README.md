# Project 12

## docs

### spec

https://drive.google.com/file/d/1Qeuor0zqUAR0Q6xGPCuwdfYDAQILjbEm/view

## todo

- [x] Array
- [x] Keyboard
- [x] Math
- [x] Memory
- [x] Output
- [x] Screen
- [x] String
- [x] Sys

## memo

- String
  - 책에서 나온 설명처럼 `setInt`를 재귀적으로 구현하는 것이 깔끔할 수 있으나, 재귀적으로 호출하면서 메모리를 많이 잡아먹으므로 Array 클래스를 스택처럼 이용하여 구현하였다. 이렇게 할 경우 스택 사이즈를 어떻게 결정할 지 미리 예상할 수 없다. 그러나 본 프로젝트는 완벽한 구현이 목적이 아니다.
- Sys
  - `wait` 함수를 구현하기 위해 while 문을 이용하여 무의미한 연산을 잠시 동안 하도록 하였다.
- Math
  - multiply, divide, sqrt 빼고는 다 직관적이다.
  - multiply도 우리가 초등학교 때 했던 대로 전체 수와 각 자리수를 곱해서 더하는 방식을 생각하면 쉽게 접근이 가능하다.
  - divide 알고리즘을 해석하는 방법은 다음과 같다. 예를 들어 19/3으로 생각해보자. 우선 분모를 계속 2배씩 하면서 나눗셈 결과가 가장 먼저 0이 되는 경우를 찾는다. 19/3 -> 19/6 -> 19/12 -> 19/24 끝. 분모가 분자보다 크니까 결과는 무조건 0이다. 그럼 그 전의 항은 결과가 무조건 1일 것이다. 만약 2 이상이었다면 분모를 2배씩 하고 있기 때문에 이번 항에서 최소한 결과가 1 이상이다. 즉, 0.25 X 19/3 의 결과가 1이고, 대충 19/3은 4정도 나올 것이다. 그러나 우리는 답이 6인 것을 알고 있다. 19/12가 정확히 1이 아니기 때문에 발생하는 문제이다. 따라서 이전 항으로 가면서 점점 더 가까이 근사해나가는 과정이 필요하다. 우선 19/12가 1인 것은 확인하였다. 이제 19/6이 얼마인지 확인하려는데, 19/12의 결과인 1에 2를 곱한 후, 분모에 있는 6과 곱한 결과인 12와 분자에 있는 19 사이에 현재 분모인 6이 1번 이상 들어갈 수 있는지 확인하는 과정이 필요하다. 12와 19 사이에는 6이 들어갈 수 있으므로 결과는 1을 더한 3이 된다. 이제 마찬가지로 19/3이 얼마인지 19/6을 통해 확인하자. 19/3은 우선 19/6의 결과인 3에 2를 곱한 6보다 같거나 클 것이다. 분모에 있는 3과 방금 계산한 6을 곱한 결과인 18과 분자에 있는 19 사이에는 3이 들어갈 수 없다. 따라서 결과는 1을 더하지 않고 6이 확정된다. 이 예시를 확장하여 수도코드로 만든 것이 책에 나와 있는 알고리즘이다.
  - sqrt 알고리즘을 해석하는 방법은 다음과 같다. 우선 음수의 루트는 계산을 하지 않을 것이기 때문에 양수만 생각한다. 양수 중에서 가장 큰 32767이 2^8 의 제곱보다 작기 때문에 2^7부터 2^6, ..., 2^0 에 대해서 계산한다. 계산은 "지금 이 숫자를 더해서 제곱했을 때 인풋보다 작거나 같게 유지될 것이냐" 에 대한 것이다. 제곱이 아니라 10진수를 2진수로 변환할 때를 연상하면 간단한데, 13이라는 숫자가 있을 때 "일단 2의 거듭제곱 중 8부터 쓰고, 남은 5를 만들기 위해 4를 쓰고, 남은 1을 만들기 위해 1을 쓰고" 해서 2진수를 만든다. 이를 다시 쓰면, 13보다 작은 2의 거듭제곱 중 큰 것부터 작은 순서대로 더해가는데, 8은 되니까 쓰고, 4는 되니까 쓰고, 2는 더하면 13을 넘어버리니까 쓰지 말고, 1은 되니까 쓰는 것이다. 이것을 sqrt에 적용해보면, 예를 들어 2^7은 되니까 쓰고, 2^6은 더해서 제곱하면 인풋을 넘어버리니까 쓰지 말고, ..., 2^0은 되니까 쓰는 것이다.
  - http://nand2tetris-questions-and-answers-forum.52.s1.nabble.com/MathTest-tst-fails-even-with-provided-OS-vm-files-td4036143.html
    - 나도 1,000,000회의 vmstep으로는 결과가 정상적으로 계산되지 않았다. 더 효율적으로 코드를 작성하면 통과하는 것인지.. 의문스럽긴 하다.
- Keyboard
  - 현재 키보드에 입력 중인 문자는 `Memory.peek(24576)` 을 이용해 알 수 있다.
  - readChar를 구현할 때는 backSpace는 출력하면 안 된다. backSpace는 어떤 문자가 화면에 출력되기를 원하고 누르는 것이 아니라 기존에 입력된 문자를 취소하고 싶은 상황인 것이다. 현재 커서에 있는 것을 무조건 지우려고 하면 기존에 콘솔에 출력된 문자까지 지워버린다.
  - readString을 구현할 때는 readChar를 무한 반복으로 읽다가, newLine을 만나는 경우 리턴하고, backSpace를 만나는 경우 현재 문자열의 길이가 1 이상일 때에 한해 `s.eraseLastChar()`, `Output.printChar(String.backSpace())` 를 연속적으로 호출하여 문자 하나를 메모리와 화면에서 지운다.
  - readInt는 readString과 String의 intValue 메소드를 이용하여 간단하게 구현할 수 있다.
- Array
  - dispose를 할 때, 자기 자신의 주소가 어차피 `Memory.alloc` 함수를 통해 받은 base address이므로 `Memory.deAlloc(this)` 를 통해 자신의 위치 자체의 메모리를 반납하면 된다.
  - Math에서와 마찬가지로 1,000,000회의 vmstep으로는 결과가 정상적으로 계산되지 않았다. 2,000,000회로 변경해두었다.
- Output
  - `printChar` 는 newLine, backSpace의 경우를 갈라 다르게 처리하고 나머지 경우에만 어떤 문자를 스크린에 출력한다. 문자를 출력할 때는 `Screen.drawPixel` 함수를 연속적으로 호출하는 방법도 있지만, 속도가 굉장히 느려진다. 직접 메모리를 참조하여 메모리의 값을 바꿔버리는 것이 훨씬 빠르다. 실제 하드웨어를 구현할 때도 이런 식으로 하지 않을까.
  - `printString` 은 `printChar`, `printInt` 는 `printString` 을 이용하여 쉽게 만들 수 있다.
- Screen
  - `drawPixel` 은 메모리 참조 주소를 찾은 후 검정색으로 칠하는 경우 00001000과 or-ing, 하얀색으로 칠하는 경우 11110111과 and-ing을 하면 된다.
  - `drawLine` 은 경우를 다음과 같이 4개로 나누어 생각한다.
    - x1==x2 && y1==y2: 그냥 점을 그리는 것이다.
    - x1==x2 && y1!=y2: vertical line을 그린다. x 좌표 고정해놓고 linear 하게 그리면 된다.
    - x1!=x2 && y1==y2: horizontal line을 그린다. y 좌표 고정해놓고 linear 하게 그리면 된다.
    - x1!=x2 && y1!=y2: a는 (x1, y1) 으로 부터 x축에서 진행한 거리, b는 y축에서 진행한 거리라고 정의한다. `b/a < dy/dx` 가 되는 경우 b++ 해서 기울기를 증가시키고, 반대의 경우 a++을 해서 기울기를 낮춰버리면 된다. 진행 방향은 4사분면과 같이 4방향으로 정의할 수 있는데, a, b, dx, dy는 양수라고 생각하고, 방향에 따라 x1 +- a, y1 +- b 에 `drawPixel` 을 하면 된다. `b/a < dy/dx` 를 매번 계산하는 것은 고비용의 작업이다. 이를 다시 쓰면 `b*dx - a*dy < 0` 이기 때문에 왼쪽 항을 변수로 선언해 두고 계속해서 그 값을 업데이트한다고 생각한다. 예를 들어, `b*dx - a*dy` 가 음수라서 b를 증가시켰다. 그 값을 b1 이라고 하자. 그러면, `b1*dx - a*dy == (b+1)*dx - a*dy = (b*dx - a*dy) + dx` 이다. 따라서 기존 값에 dx만 더해주면 된다.
  - `drawRectangle` 은 정말 간단하다. `drawLine` 을 y축에 대해서든, x축에 대해서든 그 높이 또는 너비만큼 반복하면 된다.
  - `drawCircle` 은 (x, y) 로부터 거리가 r 이하인 점들에 대해 값을 그려주면 된다. 그렇다면 피타고라스 정리, `x*x + y*y <= r*r` 을 매번 적용할 것인가? 이것은 고비용의 작업이다. `drawLine` 과 같은 트릭을 적용한다. 시작을 원 가운데의 가장 좌우로 긴 `2*r` 길이의 선을 골랐다고 하자. 고정된 y 값에 대해 y축에서 가장 멀면서 원에 포함되는 점의 거리를 a, 반대로 x축에 대한 값을 b라고 하자. b는 0, a는 r로 시작한 셈이다. xx의 값을 `a*a`, yy의 값을 `b*b`, rr의 값을 `r*r` 로 정의한다. xx, yy, rr은 변수명에서도 알 수 있듯이 피타고라스 정리에서 `x*x`, `y*y`, `r*r` 을 의미할 것이다. 이제 y축 기준으로 하나 위, 하나 아래의 선을 그리려고 한다. yy의 값은 이제 `(b+1)(b+1)` 이 되어야 할 것이다. 이것을 매번 곱셉 연산으로 계산하지 않고 완전제곱식으로 풀어 쓴 `b*b + 2*b + 1` 을 적용해보자. 기존 `b*b` 값에 `2*b + 1`, 즉 `b + b + 1` 을 더해주면 된다. 마지막으로 b를 1 증가시킨다. 이렇게 하면 yy는 완성되었다. 이제 `xx + yy <= rr` 을 만족하도록 xx의 값을 변경해야 한다. rr은 고정이고, yy가 증가했으므로 xx는 감소시키며 계산하면 된다. `(a-1)(a-1) == a*a - 2*a - 1` 이므로 `xx + yy <= rr` 을 만족할 때까지 `- a - a + 1` 을 더해주면서 a 또한 1씩 빼면 된다. 이제 `drawLine` 을 할 차례다. 가장 왼쪽은 `x-a` 로부터 가장 오른쪽은 `x+a` 이고, 현재 y는 `y-b`, `y+b` 고정이므로 `drawLine` 을 2회 하면 된다. 이렇게 해서 `a==0` 이 될 때까지 반복한다.
- Memory
  - 단순하게 구현하기 위해 first fit 방식을 적용하였다. 그런데 힙 세그먼트 사이즈가 할당하고 하는 사이즈를 x라고 할 때, x+2 이상인 경우에만 할당하도록 하였다. x+2 이상일 때 아래쪽의 x 부분을 반환하고 위에 있던 2개의 공간은 free list에서 필요한 사이즈, 다음 세그먼트 주소 정보를 가지고 있는다. 이렇게 한 것은 연결 리스트에서 하나의 노드를 삭제할 때 양방향을 잇기 위해서 필요한 복잡한 로직을 없애기 위해서이다.
  - 실제로는 aggregation 과정을 통해 쓰지 않는 메모리를 합쳐주어야 한다. 그렇지 않으면 단편화 현상 때문에 메모리를 결국에는 사용하지 못하게 될 것이다.
